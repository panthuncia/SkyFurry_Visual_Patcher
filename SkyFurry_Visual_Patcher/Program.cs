using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Noggog;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Records;
using System.Xml.Linq;
using SkyFurry_Visual_Patcher.Utilities;
using SkyFurry_Visual_Patcher.Settings;
using System.Text;
using Mutagen.Bethesda.Strings;

namespace SkyFurry_Visual_Patcher {
    public class Program {
        private static Lazy<Settings.Settings> _settings = null!;
        const string SFPatchName = "SF_Auto_Patcher.esp";
        public static async Task<int> Main(string[] args) {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch, new PatcherPreferences()
                {
                    ExclusionMods = new List<ModKey>()
                    {
                         new ModKey(SFPatchName, ModType.Plugin),
                         new ModKey("Synthesis.esp", ModType.Plugin),
                         new ModKey("Requiem for the Indifferent.esp", ModType.Plugin)
                    }
                })
                .SetAutogeneratedSettings("settings", "settings.json", out _settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, SFPatchName)
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state) {
            if (_settings.Value.patchNpcVisuals) {
                patchNPCVisuals(state);
            }
            if (_settings.Value.mergeRaces) { 
                patchRaces(state);
            }
            if (_settings.Value.mergeFlowingFur) {
                patchFlowingFur(state);
            }
            if (_settings.Value.mergeSharpClaws) {
                patchSharpClaws(state);
            }
            if (_settings.Value.mergeDigiBoots) {
                patchDigiBoots(state);
            }
        }
        /**
         * void patchNPCVisuals(IPatcherState<ISkyrimMod, ISkyrimModGetter> state) forwards all NPC edits made by SkyFurry.esp and anything which depends on it.
         */
        private static void patchNPCVisuals(IPatcherState<ISkyrimMod, ISkyrimModGetter> state) {
            //check for SkyFurry
            ISkyrimModGetter? SkyFurry = state.LoadOrder.getModByFileName(_settings.Value.SkyFurryBaseModName);

            if (SkyFurry == null) {
                System.Console.WriteLine(_settings.Value.SkyFurryBaseModName+" not found");
                return;
            }
            System.Console.WriteLine("Patching base SkyFurry visuals\n");
            //get list of mods which inherit from SkyFurry, as these may contain NPCs we need to patch
            (List<String> modNames, List<ISkyrimModGetter> modsToPatch) = state.LoadOrder.getModsFromMasterIncludingMaster(_settings.Value.SkyFurryBaseModName, SkyFurry);
            System.Console.WriteLine("\nForwarding visuals from:");
            foreach (String modName in modNames) {
                System.Console.WriteLine(modName);
            }
            int ModIndex = -1;
            foreach (ISkyrimModGetter mod in modsToPatch) {
                int processed = 0;
                int ignored = 0;
                int total = mod.Npcs.Count;
                List<FormKey> modFormIDs = mod.Npcs.Select(x => x.FormKey).ToList();
                List<INpcGetter> winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<INpcGetter>().Where(x => modFormIDs.Contains(x.FormKey)).ToList();
                ModIndex++;
                System.Console.WriteLine("\nImporting visuals from: " + modNames[ModIndex]);
                if (mod.Npcs.Count > 0) {
                    foreach (INpcGetter npc in mod.Npcs) {
                        if (processed % 10 == 0) {
                            System.Console.WriteLine(processed + "/" + total + " Npcs");
                        }
                        INpcGetter winningOverride = winningOverrides.Where(x => x.FormKey == npc.FormKey).First();
                        Npc patchNpc = state.PatchMod.Npcs.GetOrAddAsOverride(winningOverride);

                        //copy texture lighting
                        patchNpc.TextureLighting = npc.TextureLighting;

                        //copy tint layers
                        patchNpc.TintLayers.Clear();
                        foreach (ITintLayerGetter tint in npc.TintLayers) {
                            patchNpc.TintLayers.Add(tint.DeepCopy());
                        }

                        //copy head parts
                        patchNpc.HeadParts.SetTo(npc.HeadParts);

                        //copy face parts
                        if (npc.FaceParts is not null) {
                            patchNpc.FaceParts = npc.FaceParts.DeepCopy();
                        }

                        //copy head textures
                        patchNpc.HeadTexture.SetTo(npc.HeadTexture);

                        //copy face morph
                        if (npc.FaceMorph != null) {
                            patchNpc.FaceMorph = npc.FaceMorph.DeepCopy();
                        }

                        //copy hair color
                        patchNpc.HairColor.SetTo(npc.HairColor);

                        //copy race
                        patchNpc.Race.SetTo(npc.Race);

                        //copy weight
                        patchNpc.Weight = npc.Weight;

                        //copy height
                        patchNpc.Height = npc.Height;


                        //remove unchanged NPCs
                        if (_settings.Value.ignoreIdenticalToWinningOverride && patchNpc.Equals(winningOverride)) {
                            state.PatchMod.Npcs.Remove(npc);
                            ignored++;
                        }

                        processed++;
                    }
                }
                else {
                    System.Console.WriteLine("No NPCs found");
                }
                if (ignored > 0) {
                    System.Console.WriteLine("Ignoring " + ignored + " unchanged NPCs");
                }
            }
        }
        /**
         * void patchRaces(IPatcherState<ISkyrimMod, ISkyrimModGetter> state) forwards all race edits made by SkyFurry_FlowingFur.esp and anything which depends on it, 
         * allowing some fields to be overwritten by mods outside of the SkyFurry dependancy lists if they're non-visual
         * Lots of optimization is possible here, but much of what makes this function complex is to ensure compatability with mods that add content that should also be
         * patched, or add new races which use that content.
         */
        private static void patchRaces(IPatcherState<ISkyrimMod, ISkyrimModGetter> state) {
            ISkyrimModGetter? skyFurry = state.LoadOrder.getModByFileName(_settings.Value.SkyFurryBaseModName);
            //get base game files for races, backwards to ensure that when we iterate through looking for records, we always get the highest priority override first.
            List<String> baseGameFileNames = new();
            baseGameFileNames.Add("Dragonborn.esm");
            baseGameFileNames.Add("HearthFires.esm");
            baseGameFileNames.Add("Dawnguard.esm");
            baseGameFileNames.Add("Update.esm");
            baseGameFileNames.Add("Skyrim.esm");
            List<ISkyrimModGetter> baseGameFiles = new();
            foreach (String fileName in baseGameFileNames) {
                ISkyrimModGetter? file = state.LoadOrder.getModByFileName(fileName);
                if (file != null) {
                    baseGameFiles.Add(file);
                }
            }
            System.Console.WriteLine("\nChecking for SkyFurry.esp...");
            if (skyFurry != null) {
                System.Console.WriteLine("Found!");
                (List<String> modNames, List<ISkyrimModGetter> modsToPatch) = state.LoadOrder.getModsFromMasterIncludingMaster(_settings.Value.SkyFurryBaseModName, skyFurry);
                System.Console.WriteLine("mods:" + modsToPatch.Count);
                System.Console.WriteLine("mods:" + modNames.Count);

                int ModIndex = -1;
                foreach (ISkyrimModGetter mod in modsToPatch) {
                    ModIndex++;
                    int processed = 0;
                    int ignored = 0;
                    int total = mod.Races.Count;
                    List<FormKey> modFormIDs = mod.Races.Select(x => x.FormKey).ToList();
                    List<IRaceGetter> winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<IRaceGetter>().Where(x => modFormIDs.Contains(x.FormKey)).ToList();
                    System.Console.WriteLine("Processing mod: " + modNames[ModIndex]);
                    foreach (IRaceGetter race in mod.Races) {
                        if (processed % 10 == 0) {
                            System.Console.WriteLine(processed + "/" + total + " races");
                        }
                        //pull base damage races from the base game files for comparison
                        IRaceGetter? baseRaceRecord = null;
                        bool found = false;
                        bool raceInBaseGameFiles = false;
                        IRaceGetter winningOverrideRaceRecord = winningOverrides.Where(x => x.FormKey == race.FormKey).First();
                        Race patchRace = state.PatchMod.Races.GetOrAddAsOverride(winningOverrideRaceRecord);

                        //look for race in base game
                        foreach (ISkyrimModGetter? gameFile in baseGameFiles) {
                            foreach (IRaceGetter baseRace in gameFile.Races) {
                                if (baseRace.FormKey.Equals(race.FormKey)) {
                                    baseRaceRecord = baseRace;
                                    found = true;
                                    raceInBaseGameFiles = true;
                                    break;
                                }
                            }
                        }
                        //if it wasn't found there, look in this mod
                        if (!found) {
                            foreach (IRaceGetter baseRace in mod.Races) {
                                if (baseRace.FormKey.Equals(race.FormKey)) {
                                    baseRaceRecord = baseRace;
                                    found = true;
                                    break;
                                }
                            }
                        }
                        //if it's not found there, look in this mod's masters
                        if (!found) {
                            foreach (var master in mod.MasterReferences) {
                                ISkyrimModGetter? masterMod = state.LoadOrder.getModByFileName(master.Master.ToString());
                                if (masterMod != null) {
                                    foreach (IRaceGetter baseRace in masterMod.Races) {
                                        if (baseRace.FormKey.Equals(race.FormKey)) {
                                            baseRaceRecord = baseRace;
                                            found = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (!found) {
                                System.Console.WriteLine("Race not found in this file or master files, some functions will not work");
                            }
                        }
                        //now that we should have all three copies of this race record, continue
                        
                        //We'll work on a more advanced patching strategy here- we'll iterate backwards
                        //through the mods that depend on this one until we find one that includes this record.
                        //Then, we copy any effects or keywords that the winning override doesn't already contain into the patch race.
                        //this will allow us to maintain compatibility with SkyFurry patches, mods, and even custom races patched into SkyFurry
                        (List<String> secondLevelModNames, List<ISkyrimModGetter> secondLevelModsToPatch) = state.LoadOrder.getModsFromMasterIncludingMaster(_settings.Value.SkyFurryBaseModName, skyFurry);
                        secondLevelModsToPatch.Reverse();
                        secondLevelModNames.Reverse();
                        bool FoundLastReference = false;
                        IRaceGetter? lastRaceReference = null;
                        ISkyrimModGetter? lastReferenceMod = null;
                        int secondLevelModIndex = -1;
                        foreach (ISkyrimModGetter secondLevelMod in secondLevelModsToPatch) {
                            secondLevelModIndex++;
                            foreach (IRaceGetter secondLevelRace in secondLevelMod.Races) {
                                if (secondLevelRace.FormKey.Equals(race.FormKey)) {
                                    FoundLastReference = true;
                                    lastRaceReference = secondLevelRace;
                                    break;
                                }
                            }
                            //if we found the last reference, process and break
                            if (FoundLastReference && lastRaceReference is not null) {
                                System.Console.WriteLine("Found last reference to race " + race.Name + " in mod " + secondLevelModNames[secondLevelModIndex]);

                                //description, let other mods override
                                //these all have to be converted with toString() for some reason, or the equality does not evaluate properly.
                                //Will need to investigate, but works for now.
                                if (baseRaceRecord is not null) {
                                    String? baseRaceDescriptionString = baseRaceRecord.Description.ToString();
                                    if (baseRaceDescriptionString is not null && baseRaceDescriptionString.Equals(winningOverrideRaceRecord.Description.ToString())) {
                                        System.Console.WriteLine("Patching description");
                                        patchRace.Description = lastRaceReference.Description.DeepCopy();
                                    }
                                }

                                //actor effects, merge with other mods. This one's a doozy, it needs to be merged.
                                if (lastRaceReference.ActorEffect is not null) {
                                    foreach (IFormLinkGetter<ISpellRecordGetter> lastSFReferenceEffectForm in lastRaceReference.ActorEffect) {
                                        ISpellRecordGetter? lastSFReferenceEffect = lastSFReferenceEffectForm.TryResolve(state.LinkCache);
                                        bool notInBaseGame = true, notInWinningOverride = true;
                                        //look in base game race record
                                        if (raceInBaseGameFiles) {
                                            if (baseRaceRecord is not null && baseRaceRecord.ActorEffect is not null) {
                                                foreach (IFormLinkGetter<ISpellRecordGetter> baseGameRaceEffectForm in baseRaceRecord.ActorEffect) {
                                                    ISpellRecordGetter? baseGameRaceEffect = baseGameRaceEffectForm.TryResolve(state.LinkCache);
                                                    if (baseGameRaceEffect is not null && lastSFReferenceEffect is not null && baseGameRaceEffect.FormKey.Equals(lastSFReferenceEffect.FormKey)) { 
                                                        notInBaseGame = false;
                                                    }
                                                }
                                            }
                                        }
                                        //look in winning overridde
                                        if (winningOverrideRaceRecord is not null && winningOverrideRaceRecord.ActorEffect is not null) {
                                            foreach (IFormLinkGetter<ISpellRecordGetter> winningOverrideRaceEffect in winningOverrideRaceRecord.ActorEffect) {
                                                ISpellRecordGetter? resolvedFormLink = winningOverrideRaceEffect.TryResolve(state.LinkCache);
                                                if (resolvedFormLink is not null && lastSFReferenceEffect is not null && resolvedFormLink.FormKey.Equals(lastSFReferenceEffect.FormKey)) {
                                                    notInWinningOverride = false;
                                                }
                                            }
                                        }
                                        //unless it's in the base game and it's been removed by another mod, put it in the patch
                                        if (notInWinningOverride && lastSFReferenceEffect is not null && !(!notInBaseGame && notInWinningOverride)) {
                                            if (patchRace.ActorEffect == null) {
                                                patchRace.ActorEffect = new ExtendedList<IFormLinkGetter<ISpellRecordGetter>>();
                                            }
                                            System.Console.WriteLine("Adding effect: " + lastSFReferenceEffect.EditorID);
                                            patchRace.ActorEffect.Add(lastSFReferenceEffectForm);
                                        }
                                    }
                                }

                                //skin, override
                                patchRace.Skin.SetTo(lastRaceReference.Skin);                                

                                //Keywords, another big one. Same structure as actor effects. TODO: make a function that implements this structure on any IFormLinkGetter lists
                                if (lastRaceReference.Keywords is not null) {
                                    foreach (IFormLinkGetter<IKeywordGetter> lastSFReferenceKeywordForm in lastRaceReference.Keywords) {
                                        IKeywordGetter? lastSFReferenceKeyword = lastSFReferenceKeywordForm.TryResolve(state.LinkCache);
                                        bool notInBaseGame = true, notInWinningOverride = true;
                                        //look in base game race record
                                        if (raceInBaseGameFiles) {
                                            if (baseRaceRecord is not null && baseRaceRecord.Keywords is not null) {
                                                foreach (IFormLinkGetter<IKeywordGetter> baseGameRaceKeywordForm in baseRaceRecord.Keywords) {
                                                    IKeywordGetter? baseGameRaceKeyword = baseGameRaceKeywordForm.TryResolve(state.LinkCache);
                                                    if (baseGameRaceKeyword is not null && lastSFReferenceKeyword is not null && baseGameRaceKeyword.FormKey.Equals(lastSFReferenceKeyword.FormKey)) {
                                                        notInBaseGame = false;
                                                    }
                                                }
                                            }
                                        }
                                        //look in winning overridde
                                        if (winningOverrideRaceRecord is not null && winningOverrideRaceRecord.Keywords is not null) {
                                            foreach (IFormLinkGetter<IKeywordGetter> winningOverrideRaceKeyword in winningOverrideRaceRecord.Keywords) {
                                                IKeywordGetter? resolvedFormLink = winningOverrideRaceKeyword.TryResolve(state.LinkCache);
                                                if (resolvedFormLink is not null && lastSFReferenceKeyword is not null && resolvedFormLink.FormKey.Equals(lastSFReferenceKeyword.FormKey)) {
                                                    notInWinningOverride = false;
                                                }
                                            }
                                        }
                                        //unless it's in the base game and it's been removed by another mod, put it in the patch
                                        if (notInWinningOverride && lastSFReferenceKeyword is not null && !(!notInBaseGame&&notInWinningOverride)) {
                                            if (patchRace.Keywords == null) {
                                                patchRace.Keywords = new ExtendedList<IFormLinkGetter<IKeywordGetter>>();
                                            }
                                            System.Console.WriteLine("Adding keyword: " + lastSFReferenceKeyword.EditorID);
                                            patchRace.Keywords.Add(lastSFReferenceKeywordForm);
                                        }
                                    }
                                }

                                //first person flags
                                //make sure that if the last reference has a body template, the patch race does too.
                                if (patchRace.BodyTemplate is null && lastRaceReference.BodyTemplate is not null) {
                                    patchRace.BodyTemplate = new BodyTemplate();
                                }
                                if (lastRaceReference.BodyTemplate is not null && patchRace.BodyTemplate is not null) {
                                    patchRace.BodyTemplate.FirstPersonFlags = lastRaceReference.BodyTemplate.FirstPersonFlags;
                                }

                                //patch skill boosts, primarily for Dremora, allow other mods to override
                                if (baseRaceRecord is not null) {
                                    if (!baseRaceRecord.SkillBoost0.Equals(lastRaceReference.SkillBoost0) &&winningOverrideRaceRecord.SkillBoost0.Equals(baseRaceRecord.SkillBoost0)) {
                                        patchRace.SkillBoost0 = lastRaceReference.SkillBoost0.DeepCopy();
                                    }
                                    if (!baseRaceRecord.SkillBoost1.Equals(lastRaceReference.SkillBoost1) && winningOverrideRaceRecord.SkillBoost0.Equals(baseRaceRecord.SkillBoost0)) {
                                        patchRace.SkillBoost1 = lastRaceReference.SkillBoost1.DeepCopy();
                                    }
                                    if (!baseRaceRecord.SkillBoost2.Equals(lastRaceReference.SkillBoost2) && winningOverrideRaceRecord.SkillBoost0.Equals(baseRaceRecord.SkillBoost0)) {
                                        patchRace.SkillBoost2 = lastRaceReference.SkillBoost2.DeepCopy();
                                    }
                                    if (!baseRaceRecord.SkillBoost3.Equals(lastRaceReference.SkillBoost3) && winningOverrideRaceRecord.SkillBoost0.Equals(baseRaceRecord.SkillBoost0)) {
                                        patchRace.SkillBoost3 = lastRaceReference.SkillBoost3.DeepCopy();
                                    }
                                    if (!baseRaceRecord.SkillBoost4.Equals(lastRaceReference.SkillBoost4) && winningOverrideRaceRecord.SkillBoost0.Equals(baseRaceRecord.SkillBoost0)) {
                                        patchRace.SkillBoost4 = lastRaceReference.SkillBoost4.DeepCopy();
                                    }
                                    if (!baseRaceRecord.SkillBoost5.Equals(lastRaceReference.SkillBoost5) && winningOverrideRaceRecord.SkillBoost0.Equals(baseRaceRecord.SkillBoost0)) {
                                        patchRace.SkillBoost5 = lastRaceReference.SkillBoost5.DeepCopy();
                                    }
                                    if (!baseRaceRecord.SkillBoost6.Equals(lastRaceReference.SkillBoost6) && winningOverrideRaceRecord.SkillBoost0.Equals(baseRaceRecord.SkillBoost0)) {
                                        patchRace.SkillBoost6 = lastRaceReference.SkillBoost6.DeepCopy();
                                    }
                                }

                                //patch biped objects, also primarily for Dremora, override
                                patchRace.HeadBipedObject = lastRaceReference.HeadBipedObject;
                                patchRace.HairBipedObject = lastRaceReference.HairBipedObject;
                                patchRace.BodyBipedObject = lastRaceReference.BodyBipedObject;

                                //patch base stats, allow other mods to override.
                                if (baseRaceRecord is not null && winningOverrideRaceRecord.Regen.Equals(baseRaceRecord.Regen)) {
                                    patchRace.Regen.SetTo(lastRaceReference.Regen);
                                }
                                if (baseRaceRecord is not null && winningOverrideRaceRecord.UnarmedReach.Equals(baseRaceRecord.UnarmedReach)) {
                                    patchRace.UnarmedReach = lastRaceReference.UnarmedReach;
                                }
                                if (baseRaceRecord is not null && winningOverrideRaceRecord.BaseCarryWeight.Equals(baseRaceRecord.BaseCarryWeight)) {
                                    patchRace.BaseCarryWeight = lastRaceReference.BaseCarryWeight;
                                }
                                //height, override
                                patchRace.Height.Male = lastRaceReference.Height.Male;
                                patchRace.Height.Female = lastRaceReference.Height.Male;

                                //skeleton, override
                                if (lastRaceReference.SkeletalModel is not null && lastRaceReference.SkeletalModel.Male is not null) {
                                    if (patchRace.SkeletalModel is not null) {
                                        patchRace.SkeletalModel.Male = lastRaceReference.SkeletalModel.Male.DeepCopy();
                                    }
                                }
                                if (lastRaceReference.SkeletalModel is not null && lastRaceReference.SkeletalModel.Female is not null) {
                                    if (patchRace.SkeletalModel is not null) {
                                        patchRace.SkeletalModel.Female = lastRaceReference.SkeletalModel.Female.DeepCopy();
                                    }
                                }

                                //Patch decapitate armours, override
                                if (lastRaceReference.DecapitateArmors is not null && lastRaceReference.DecapitateArmors.Male is not null) {
                                    if (patchRace.DecapitateArmors is not null) {
                                        patchRace.DecapitateArmors.Male = lastRaceReference.DecapitateArmors.Male;
                                    }
                                }
                                if (lastRaceReference.DecapitateArmors is not null && lastRaceReference.DecapitateArmors.Female is not null) {
                                    if (patchRace.DecapitateArmors is not null) {
                                        patchRace.DecapitateArmors.Female = lastRaceReference.DecapitateArmors.Female;
                                    }
                                }
                                //patch tints and head data, override
                                patchRace.NumberOfTintsInList = lastRaceReference.NumberOfTintsInList;
                                if (lastRaceReference.HeadData is not null && lastRaceReference.HeadData.Male is not null) {
                                    if (patchRace.HeadData is not null) {
                                        patchRace.HeadData.Male = lastRaceReference.HeadData.Male.DeepCopy();
                                    }
                                }
                                if (lastRaceReference.HeadData is not null && lastRaceReference.HeadData.Female is not null) {
                                    if (patchRace.HeadData is not null) {
                                        patchRace.HeadData.Female = lastRaceReference.HeadData.Female.DeepCopy();
                                    }
                                }
                                //patch impact data, override
                                patchRace.ImpactDataSet.SetTo(lastRaceReference.ImpactDataSet);

                                //patch biped object names (tail), override
                                patchRace.BipedObjectNames.SetTo(lastRaceReference.BipedObjectNames);

                                //patch hair, override
                                if (lastRaceReference.DefaultHairColors is not null) {
                                    patchRace.DefaultHairColors = new GenderedItem<IFormLinkGetter<IColorRecordGetter>>(lastRaceReference.DefaultHairColors.Male, lastRaceReference.DefaultHairColors.Female);
                                }
                                else {
                                    patchRace.DefaultHairColors = null;
                                }

                                //patch relevant flags
                                if (baseRaceRecord is not null && lastRaceReference.Flags.HasFlag(Race.Flag.Playable) && !baseRaceRecord.Flags.HasFlag(Race.Flag.Playable)) {
                                    System.Console.WriteLine("Found a race which should be made playable, patching");
                                    //Flags cannot be set directly with setFlag(). That's annoying.
                                    patchRace.Flags = patchRace.Flags.SetFlag(Race.Flag.Playable, true);
                                }
                                if (baseRaceRecord is not null && lastRaceReference.Flags.HasFlag(Race.Flag.AllowMountedCombat) && !baseRaceRecord.Flags.HasFlag(Race.Flag.AllowMountedCombat)) {
                                    patchRace.Flags = patchRace.Flags.SetFlag(Race.Flag.AllowMountedCombat, true);
                                }
                                //we're done, break out of loop
                                break;
                            }
                        }
                        processed++;

                    }
                }
            }
        }
        /**
         * void patchFlowingFur(IPatcherState<ISkyrimMod, ISkyrimModGetter> state) forwards all edits made by SkyFurry_FlowingFur.esp and anything which depends on it.
         */
        private static void patchFlowingFur(IPatcherState<ISkyrimMod, ISkyrimModGetter> state) {
            //Now check for flowing fur addon and forward changes from it and anything that inherits from it
            ISkyrimModGetter? FlowingFur = state.LoadOrder.getModByFileName(_settings.Value.FlowingFurModName);
            System.Console.WriteLine("\nChecking for flowing fur...");
            if (FlowingFur != null) {
                System.Console.WriteLine("Found!");
                //get a list of furs added by SkyFurry_FlowingFur.esp so that we can detect them in NPCs
                List<FormKey> furTypes = new();
                foreach (IArmorGetter furType in FlowingFur.Armors) {
                        furTypes.Add(furType.FormKey);
                }
                (List<String> modNames, List<ISkyrimModGetter> modsToPatch) = state.LoadOrder.getModsFromMasterIncludingMaster(_settings.Value.FlowingFurModName, FlowingFur);
                int ModIndex = -1;
                foreach (ISkyrimModGetter mod in modsToPatch) {
                    int processed = 0;
                    int ignored = 0;
                    int total = mod.Outfits.Count;
                    List<FormKey> modFormIDs = mod.Outfits.Select(x => x.FormKey).ToList();
                    List<IOutfitGetter> winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<IOutfitGetter>().Where(x => modFormIDs.Contains(x.FormKey)).ToList();
                    ModIndex++;
                    System.Console.WriteLine("\nImporting furs from: " + modNames[ModIndex]);
                    if (mod.Outfits.Count > 0) {
                        foreach (IOutfitGetter outfit in mod.Outfits) {
                            if (processed % 10 == 0) {
                                System.Console.WriteLine(processed + "/" + total + " outfits");
                            }
                            IOutfitGetter winningOverride = winningOverrides.Where(x => x.FormKey == outfit.FormKey).First();
                            Outfit patchOutfit = state.PatchMod.Outfits.GetOrAddAsOverride(winningOverride);
                            if (outfit.Items is not null) {
                                List<IOutfitTargetGetter> fursToRemove = new();
                                //Entries in outfit item lists are IFormLinkGetter, which need to be resolved with TryResolve(state.LinkCache) instead of being accessed directly.
                                foreach (IFormLinkGetter<IOutfitTargetGetter> itemForm in outfit.Items) {
                                    IOutfitTargetGetter? item = itemForm.TryResolve(state.LinkCache);
                                    if (item is not null && furTypes.Contains(item.FormKey)) {
                                        //Apparently the item list can be null, so if we need to add fur we need to check for this
                                        if (patchOutfit.Items is null) {
                                            patchOutfit.Items = new ExtendedList<IFormLinkGetter<IOutfitTargetGetter>>();
                                        }
                                        //mark any existing furs for deletion. We can't delete them here because we can't iterate on an ExtendedList and modify it at the same time
                                        foreach (IFormLinkGetter<IOutfitTargetGetter> potentialFurForm in patchOutfit.Items) {
                                            IOutfitTargetGetter? potentialFurItem = potentialFurForm.TryResolve(state.LinkCache);
                                            if (potentialFurItem is not null && furTypes.Contains(potentialFurItem.FormKey)) {
                                                fursToRemove.Add(potentialFurItem);
                                            }
                                        }
                                        patchOutfit.Items.Add(itemForm);
                                    }
                                }
                                //remove duplicate furs
                                foreach (IOutfitTargetGetter fur in fursToRemove) {
                                    if (patchOutfit.Items is not null) {
                                        patchOutfit.Items.Remove(fur);
                                    }
                                }
                            }
                            //remove unchanged outfits
                            if (patchOutfit.Equals(winningOverride)) {
                                state.PatchMod.Outfits.Remove(outfit);
                                ignored++;
                            }

                            processed++;
                        }
                    }
                    else {
                        System.Console.WriteLine("No NPCs found");
                    }
                    System.Console.WriteLine("Ignoring " + ignored + " unchanged Outfits");
                }
            }
        }
        /**
         * void patchSharpClaws(IPatcherState<ISkyrimMod, ISkyrimModGetter> state) forwards all edits made by SkyFurry_SharpClaws.esp and anything which depends on it.
         * Lots of optimization is possible here, but much of what makes this function complex is to ensure compatability with mods that add content that should also be
         * patched, or add new races which use that content.
         */
        private static void patchSharpClaws(IPatcherState<ISkyrimMod, ISkyrimModGetter> state) {
            ISkyrimModGetter? sharpClaws = state.LoadOrder.getModByFileName(_settings.Value.SharpClawsModName);
            if (sharpClaws == null) {
                System.Console.WriteLine(_settings.Value.SharpClawsModName+" not found");
                return;
            }
            ISkyrimModGetter? skyFurry = state.LoadOrder.getModByFileName(_settings.Value.SkyFurryBaseModName);
            if (skyFurry == null) {
                System.Console.WriteLine(_settings.Value.SkyFurryBaseModName+" not found");
                return;
            }
            System.Console.WriteLine("\nChecking for sharp claws...");
            if (sharpClaws != null) {
                System.Console.WriteLine("Found!");
                List<FormKey> modFormIDs = sharpClaws.Races.Select(x => x.FormKey).ToList();
                List<IRaceGetter> winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<IRaceGetter>().Where(x => modFormIDs.Contains(x.FormKey)).ToList();
                //list sharpclaws spells
                //patch races
                (List<String> modNames, List<ISkyrimModGetter> modsToPatch) = state.LoadOrder.getModsFromMasterIncludingMaster(_settings.Value.SharpClawsModName, sharpClaws);
                foreach (ISkyrimModGetter mod in modsToPatch) {
                    List<FormKey> sharpClaws_Spells = new();
                    //get all of the spells added by this mod
                    foreach (ISpellGetter spell in mod.Spells) {
                        sharpClaws_Spells.Add(spell.FormKey);
                    }
                    //get all of the spells added by this mods masters, as long as that master also has SharpClaws as a master.
                    //This could add unrelated spells, but shouldn't cause many issues, but there could be some problematic edge cases.
                    //it is necessary in order to support new SharpClaws spells added by extensions to SharpClaws that inherit from it.  
                    foreach (var master in mod.MasterReferences) {
                        ISkyrimModGetter? masterMod = state.LoadOrder.getModByFileName(master.Master.ToString());
                        if (masterMod != null) {
                            //to avoid pulling every spell from the base game and every mod we might have a SharpClaws patch for, we check that the master mod itself inherits from SharpClaws.
                            bool inheritsFromSharpClaws = false;
                            foreach (IMasterReferenceGetter masterForSpellCheck in masterMod.MasterReferences) {
                                if (masterForSpellCheck.Master.ToString().Equals(_settings.Value.SharpClawsModName)){
                                    inheritsFromSharpClaws = true;
                                    break;
                                }
                            }
                            //if the master inherits from SharpClaws
                            if (inheritsFromSharpClaws) {
                                foreach (ISpellGetter spell in masterMod.Spells) {
                                    sharpClaws_Spells.Add(spell.FormKey);
                                }
                            }
                        }
                    }
                    int processed = 0;
                    int total = mod.Races.Count;
                    foreach (IRaceGetter race in mod.Races) {
                        if (processed % 10 == 0) {
                            System.Console.WriteLine(processed + "/" + total + " Races");
                        }
                        IRaceGetter winningOverride = winningOverrides.Where(x => x.FormKey == race.FormKey).First();
                        Race patchRace = state.PatchMod.Races.GetOrAddAsOverride(winningOverride);

                        //patch impact data
                        patchRace.ImpactDataSet.SetTo(race.ImpactDataSet);

                        //patch actor effects
                        //list winning override actor effects
                        List<FormKey> winningOverrideActorEffects = new();
                        if (winningOverride.ActorEffect is not null) {
                            //another IFormLinkGetter
                            foreach (IFormLinkGetter<ISpellRecordGetter> effectForm in winningOverride.ActorEffect) {
                                ISpellRecordGetter? effect = effectForm.TryResolve(state.LinkCache);
                                if (effect is not null) {
                                    winningOverrideActorEffects.Add(effect.FormKey);
                                }
                            }
                        }
                        //check every race effect record in the current mod, and if it is in SkyFurry_SharpClaws.esp or anything that inherits from it but is not in the winning override, add it to the patch
                        if (race.ActorEffect is not null) {
                            foreach (IFormLinkGetter<ISpellRecordGetter> effectForm in race.ActorEffect) {
                                ISpellRecordGetter? effect = effectForm.TryResolve(state.LinkCache);
                                if (effect is not null && (sharpClaws_Spells.Contains(effect.FormKey)) && !winningOverrideActorEffects.Contains(effect.FormKey)) {
                                    if (patchRace.ActorEffect is null) {
                                        patchRace.ActorEffect = new ExtendedList<IFormLinkGetter<ISpellRecordGetter>>();
                                    }
                                    patchRace.ActorEffect.Add(effectForm);
                                }
                            }
                        }
                        //forward unarmed damage modifiers.
                        //if set, scale race unarmed damage with the same scaling factor applied to the winning override
                        if (_settings.Value.scaleUnarmedDamageWithWinningOverride) {
                            //pull base damage values from SkyFurry.esp and calculate scaling factor from the winning override
                            float baseRaceDamage = 4;
                            bool found = false;
                            //look for race in SkyFurry
                            foreach (IRaceGetter baseRace in skyFurry.Races) {
                                if (baseRace.FormKey.Equals(race.FormKey)) {
                                    baseRaceDamage = baseRace.UnarmedDamage;
                                    found = true;
                                    break;
                                }
                            }
                            //if it wasn't found there, look in this mod
                            if (!found) {
                                foreach (IRaceGetter baseRace in mod.Races) {
                                    if (baseRace.FormKey.Equals(race.FormKey)) {
                                        baseRaceDamage = baseRace.UnarmedDamage;
                                        found = true;
                                        break;
                                    }
                                }
                            }
                            //if it's not found there, look in this mod's masters
                            if (!found) {
                                foreach (var master in mod.MasterReferences) {
                                    ISkyrimModGetter? masterMod = state.LoadOrder.getModByFileName(master.Master.ToString());
                                    if (masterMod != null) {
                                        foreach (IRaceGetter baseRace in masterMod.Races) {
                                            if (baseRace.FormKey.Equals(race.FormKey)) {
                                                baseRaceDamage = baseRace.UnarmedDamage;
                                                found = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                                if (!found) {
                                    System.Console.WriteLine("Mystery race, ig");
                                }
                            }
                            foreach (IRaceGetter baseRace in skyFurry.Races) {
                                if (baseRace.FormKey.Equals(race.FormKey)) {
                                    baseRaceDamage = baseRace.UnarmedDamage;
                                    found = true;
                                }
                            }
                            float scaleFactor = winningOverride.UnarmedDamage / baseRaceDamage;
                            //apply scaling factor to SharpClaws damage 
                            patchRace.UnarmedDamage = race.UnarmedDamage * scaleFactor;
                        }
                        else {
                            patchRace.UnarmedDamage = race.UnarmedDamage;
                        }
                        processed++;
                    }
                }
            }
        }
        /**
         * void patchDigiBoots(IPatcherState<ISkyrimMod, ISkyrimModGetter> state) forwards all edits made by SF_Digiboots.esp and anything which depends on it.
         */
        private static void patchDigiBoots(IPatcherState<ISkyrimMod, ISkyrimModGetter> state) {
            //Now check for flowing fur addon and forward changes from it and anything that inherits from it
            ISkyrimModGetter? digiBoots = state.LoadOrder.getModByFileName(_settings.Value.DigibootsModName);
            System.Console.WriteLine("\nChecking for digiboots...");
            if (digiBoots != null) {
                System.Console.WriteLine("Found!");
                (List<String> modNames, List<ISkyrimModGetter> modsToPatch) = state.LoadOrder.getModsFromMasterIncludingMaster(_settings.Value.DigibootsModName, digiBoots);
                int ModIndex = -1;
                foreach (ISkyrimModGetter mod in modsToPatch) {
                    int processed = 0;
                    int ignored = 0;
                    int totalArmors = mod.Armors.Count;
                    int totalArmorAddons = mod.ArmorAddons.Count;
                    //lists of armors and armor addons
                    List<FormKey> modArmorFormIDs = mod.Armors.Select(x => x.FormKey).ToList();
                    List<FormKey> modArmorAddonFormIDs = mod.ArmorAddons.Select(x => x.FormKey).ToList();
                    List<IArmorGetter> winningArmorOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<IArmorGetter>().Where(x => modArmorFormIDs.Contains(x.FormKey)).ToList();
                    List<IArmorAddonGetter> winningArmorAddonOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<IArmorAddonGetter>().Where(x => modArmorAddonFormIDs.Contains(x.FormKey)).ToList();
                    ModIndex++;
                    //get base game files
                    List<String> baseGameFileNames = new();
                    baseGameFileNames.Add("Dragonborn.esm");
                    baseGameFileNames.Add("HearthFires.esm");
                    baseGameFileNames.Add("Dawnguard.esm");
                    baseGameFileNames.Add("Update.esm");
                    baseGameFileNames.Add("Skyrim.esm");
                    List<ISkyrimModGetter> baseGameFiles = new();
                    foreach (String fileName in baseGameFileNames) {
                        ISkyrimModGetter? file = state.LoadOrder.getModByFileName(fileName);
                        if (file != null) {
                            baseGameFiles.Add(file);
                        }
                    }
                    System.Console.WriteLine("\nImporting armors from: " + modNames[ModIndex]);
                    if (mod.Armors.Count > 0) {
                        foreach (IArmorGetter armor in mod.Armors) {
                            IArmorGetter? baseArmorRecord = null;
                            bool armorInBaseGameFiles = false;
                            bool found = false;
                            //look for boots in base game
                            foreach (ISkyrimModGetter? gameFile in baseGameFiles) {
                                foreach (IArmorGetter baseArmor in gameFile.Armors) {
                                    if (baseArmor.FormKey.Equals(armor.FormKey)) {
                                        baseArmorRecord = baseArmor;
                                        found = true;
                                        armorInBaseGameFiles = true;
                                        break;
                                    }
                                }
                            }
                            //if it wasn't found there, look in this mod
                            if (!found) {
                                foreach (IArmorGetter baseArmor in mod.Armors) {
                                    if (baseArmor.FormKey.Equals(armor.FormKey)) {
                                        baseArmorRecord = baseArmor;
                                        found = true;
                                        break;
                                    }
                                }
                            }
                            //if it's not found there, look in this mod's masters
                            if (!found) {
                                foreach (var master in mod.MasterReferences) {
                                    ISkyrimModGetter? masterMod = state.LoadOrder.getModByFileName(master.Master.ToString());
                                    if (masterMod != null) {
                                        foreach (IArmorGetter baseArmor in masterMod.Armors) {
                                            if (baseArmor.FormKey.Equals(armor.FormKey)) {
                                                baseArmorRecord = baseArmor;
                                                found = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                                if (!found) {
                                    System.Console.WriteLine("Race not found in this file or master files, some functions will not work");
                                }
                            }
                            if (processed % 10 == 0) {
                                System.Console.WriteLine(processed + "/" + totalArmors + " armors");
                            }
                            IArmorGetter winningArmorOverride = winningArmorOverrides.Where(x => x.FormKey == armor.FormKey).First();
                            Armor patchArmor = state.PatchMod.Armors.GetOrAddAsOverride(winningArmorOverride);

                            if (patchArmor.BodyTemplate is null) { 
                                patchArmor.BodyTemplate = new BodyTemplate();
                            }
                            if (armor.BodyTemplate is not null) {
                                patchArmor.BodyTemplate.FirstPersonFlags = armor.BodyTemplate.FirstPersonFlags;
                            }
                            //patch world model
                            if (armor.WorldModel is not null) {
                                if(armor.WorldModel.Male is not null && armor.WorldModel.Female is not null) { 
                                    patchArmor.WorldModel = new GenderedItem<ArmorModel?>(armor.WorldModel.Male.DeepCopy(), armor.WorldModel.Female.DeepCopy());
                                }
                                else if (armor.WorldModel.Male is not null && armor.WorldModel.Female is null) {
                                    patchArmor.WorldModel = new GenderedItem<ArmorModel?>(armor.WorldModel.Male.DeepCopy(), null);
                                }
                                else if (armor.WorldModel.Male is null && armor.WorldModel.Female is not null) {
                                    patchArmor.WorldModel = new GenderedItem<ArmorModel?>(null, armor.WorldModel.Female.DeepCopy());
                                }
                            }
                            else {
                                patchArmor.WorldModel = null;
                            }
                            //patch object bounds
                            if (baseArmorRecord is not null && !armor.ObjectBounds.Equals(baseArmorRecord.ObjectBounds)) {
                                patchArmor.ObjectBounds = armor.ObjectBounds.DeepCopy();
                            }

                            //remove unchanged armors
                            if (patchArmor.Equals(winningArmorOverride)) {
                                state.PatchMod.Armors.Remove(patchArmor);
                                ignored++;
                            }

                            processed++;
                        }
                    }
                    else {
                        System.Console.WriteLine("No NPCs found");
                    }
                    System.Console.WriteLine("Ignoring " + ignored + " unchanged Outfits");
                }
            }
        }
    }
}

